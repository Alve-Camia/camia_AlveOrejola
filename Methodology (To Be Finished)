TO BE FINISHED - For now, please ignore this file because it is currently not final and will be updated if time is avialable.

Detailed Methodology
Self-Record Attendance System

Methodology Contents
1. Implementation of Core Features
  1.1 Log in and Log Out
    1.1.1 Log In
    1.1.2 Log Out
    1.1.3 Account Creation (Sign Up)
  1.2 Attendance Features
    1.2.1 Create Attendance
    1.2.2 View Attendance/s
    1.2.3 Fill Out Attendance
2. Technologies Used (with justification)
  2.1 Python
  2.2 Tkinter
  2.3 bcrypt (Additionally known as Blowfish crypt)
  2.4 SQLite
3. Backend-frontend communication
  3.1 Tkinter (Frontend)
  3.2 Python (Backend)
  3.3 SQLite (Storage)
4. Key Design decisions or Trade-offs
  4.1 Manual Date and Time Input
  4.2 Single-file Architecture
  4.3 Pop-up validation messages
  4.4 Database Usage (SQLite)
5. References to Ethical Considerations in Programming Choices
  5.1 User Privacy
  5.2 Data Minimization
  5.3 Accessibility
6. References

Methodology

1. Implementation of Core Features
The following content in Section 1 of the methodology contains how were the features of the Self-Record Attendance System were implementated. 
Currently, there are three main features made: user authentication feature, atendance Feature, and system time feature. Note that these aren't the only features of the program
1.1 Log in and Log Out
1.1.1 Log in
The login and log out feaure of the program was implemented using a username (account name) and password system, which additionally used a database storage (SQLite). When the user enters their account name and password and presses the "Log In" button, the program accepts the user's input and compares it to the current data in the database. As of now, the code assumes that the connection will always work, though in real-world scenarios it wouldn't for reasons such as file permissions, corrupted/missing database.

First, the program checks if the user has inputted empty entries for the entry boxes (Empty entries in this case are inputs that are only spaces and inputs that do not have input characters). If the user entered an empty entry, the program would notify the user via a pop-up message stating that there is an empty entry. Otherwise, the program will accept what the user has entered. Next, the program checks if the entered account name exists in the data storage (if not, give the user a pop-up message regarding it). If the entered account name does exist, it then compares the entered password to the password that corresponds to the account name in the data storage via bcrypt.checkpw(), which does so by the following:

bcrypt.checkpw(plaintext, stored_hash): Note that plaintext and stored_hash would need to be bytes for this to work.
